// Generated by CoffeeScript 1.6.3
var d3, dumpNode, nodeDescription, partitionize, pruneIdle, removeEmptyChildren, updateIdentifiedNode;

d3 = require("d3");

exports.render = function(sel, profile) {
  var boxHeight, chart, depth, fontSize, g, h, nodes, partition, profClick, root, svg, w, x, y;
  pruneIdle(profile.head);
  root = removeEmptyChildren(profile.head);
  partitionize(root);
  partition = d3.layout.partition().value(function(d) {
    return d.selfTime;
  }).sort(null);
  nodes = partition.nodes(root);
  depth = Math.max.apply(null, nodes.map(function(d) {
    return d.depth;
  }));
  d3.selectAll("" + sel + " svg").remove();
  boxHeight = 40;
  fontSize = 15;
  g = null;
  w = 1000;
  h = boxHeight * depth;
  x = d3.scale.linear().range([0, w]);
  y = d3.scale.linear().range([0, h]);
  profClick = function(d) {
    var offset, scale, t;
    if (!d.children) {
      return;
    }
    d3.event.stopPropagation();
    scale = w / x(d.dx);
    offset = -x(d.x) * scale;
    t = g.transition().duration(d3.event.altKey ? 7500 : 750).attr("transform", function(d) {
      return "translate(" + (offset + scale * x(d.x)) + "," + (h - y(d.y) - boxHeight) + ")";
    });
    t.select("rect").attr("width", function(d) {
      return scale * x(d.dx);
    });
    t.select(".clippath").select("rect").attr("width", function(d) {
      return scale * x(d.dx);
    });
    return t.select("text").attr("text-anchor", "middle").attr("x", function(d) {
      return scale * x(d.dx) / 2;
    });
  };
  chart = d3.select(sel).style("zzz-width", w + "px").style("zzz-height", h + "px");
  svg = chart.append("svg:svg").attr("width", w).attr("height", h).attr("viewBox", "0 0 " + w + " " + h).attr("zzz-preserveAspectRatio", "xMidYMin");
  g = svg.selectAll("g").data(nodes).enter().append("svg:g").attr("transform", function(d) {
    return "translate(" + x(d.x) + "," + (h - y(d.y) - boxHeight) + ")";
  }).on("click", profClick).on("mouseover", updateIdentifiedNode);
  g.append("svg:title").text(nodeDescription);
  g.append("svg:rect").attr("width", function(d) {
    return x(d.dx);
  }).attr("height", function(d) {
    return y(d.dy);
  }).attr("class", function(d) {
    return "parent";
  }).style("opacity", function(d) {
    var value;
    if (!d.parent) {
      return 1;
    }
    if (d.parent && d.parent.totalTime >= 0 && d.totalTime >= 0) {
      value = 0.3 + (0.7 * (d.totalTime / d.parent.totalTime));
      return value;
    }
  }).classed("invisible", function(d) {
    return d.invisible;
  });
  g.append("svg:clipPath").property("id", function(d, i) {
    return "text-clip-path-" + i;
  }).classed("clippath", true).append("svg:rect").attr("width", function(d) {
    return x(d.dx);
  }).attr("height", function(d) {
    return y(d.dy);
  });
  g.append("svg:text").attr("x", function(d) {
    return x(d.dx) / 2;
  }).attr("y", h / depth - fontSize).attr("text-anchor", "middle").attr("font-size", fontSize).attr("font-family", "Verdana").style("clip-path", function(d, i) {
    return "url(#text-clip-path-" + i + ")";
  }).text(function(d) {
    var func;
    if (d.invisible) {
      return "";
    }
    func = d.functionName || "<anon>";
    return func + "()";
  });
  return d3.select(window).on("click", function() {
    return profClick(root);
  });
};

pruneIdle = function(node, parentNode) {
  var child, _i, _len, _ref;
  if (parentNode == null) {
    parentNode = {};
  }
  if (node.functionName === "(program)") {
    if (parentNode.functionName === "(root)") {
      parentNode.totalTime -= node.selfTime;
      parentNode.totalSamples -= node.selfSamples;
      node.totalTime -= node.selfTime;
      node.selfTime = 0;
      node.totalSamples -= node.selfSamples;
      node.selfSamples = 0;
      return;
    }
  }
  _ref = node.children;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    pruneIdle(child, node);
  }
};

dumpNode = function(node) {
  console.log("node: " + node.functionName);
  console.log("    selfTime:     " + node.selfTime);
  console.log("    totalTime:    " + node.totalTime);
  console.log("    selfSamples:  " + node.selfSamples);
  console.log("    totalSamples: " + node.totalSamples);
};

removeEmptyChildren = function(parent) {
  var child, _i, _len, _ref;
  if (!parent.children) {
    return;
  }
  if (!parent.children.length) {
    delete parent.children;
    return;
  }
  _ref = parent.children;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    removeEmptyChildren(child);
  }
  return parent;
};

partitionize = function(node) {
  var child, _i, _len, _ref;
  if (!node.children) {
    return;
  }
  if (!node.children.length) {
    return;
  }
  _ref = node.children;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    child = _ref[_i];
    partitionize(child);
  }
  return node.children.push({
    selfTime: node.selfTime,
    invisible: true
  });
};

nodeDescription = function(node) {
  var file, func, line, message;
  if (node.invisible) {
    return;
  }
  func = node.functionName;
  file = node.scriptName;
  line = node.lineNumber;
  if (!func || func === "") {
    func = "<anonymous>";
  } else {
    func += "()";
  }
  if (!file || file === "") {
    file = "<no file>";
  }
  if (!line) {
    line = "";
  }
  message = func + "\n" + "   file: " + file + ":" + line + "\n" + "   selfTime:  " + node.selfTime + "\n" + "   totalTime: " + node.totalTime;
  return message;
};

updateIdentifiedNode = function(node) {
  var file, func, line, message;
  if (node.invisible) {
    return;
  }
  func = node.functionName;
  file = node.scriptName;
  line = node.lineNumber;
  if (!func || func === "") {
    func = "<anonymous>";
  } else {
    func += "()";
  }
  if (!file || file === "") {
    file = "<no file>";
  }
  if (!line) {
    line = "";
  }
  return message = func + " in " + file + ":" + line + "\n" + "   called:    " + node.numberOfCalls + " times\n" + "   selfTime:  " + node.selfTime + "\n" + "   totalTime: " + node.totalTime;
};
