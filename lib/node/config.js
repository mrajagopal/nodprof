// Generated by CoffeeScript 1.6.3
var fs, getConfigurationCommandLine, getConfigurationConfig, getConfigurationDefault, getConfigurationEnv, logger, mkdirp, nopt, parseCommandLine, path, pkg, utils, _;

fs = require("fs");

path = require("path");

nopt = require("nopt");

_ = require("underscore");

pkg = require("../../package.json");

utils = require("../common/utils");

logger = require("../common/logger");

exports.getConfiguration = function(argv) {
  var args, cCfg, cCmd, cDef, cEnv, cFile, config, data, opts, _ref;
  _ref = parseCommandLine(argv), args = _ref.args, opts = _ref.opts;
  cDef = getConfigurationDefault();
  cCmd = getConfigurationCommandLine(opts);
  cFile = cCmd.config || cDef.config;
  cEnv = getConfigurationEnv();
  cCfg = getConfigurationConfig(cFile);
  config = _.defaults({}, cCmd, cEnv, cCfg, cDef);
  delete config.config;
  data = mkdirp(config.data);
  if (data == null) {
    logger.log("data directory not found or not writable: " + config.data);
    process.exit(1);
  }
  return {
    args: args,
    config: config
  };
};

mkdirp = function(dir) {
  var e, exists, parent, result, stats;
  exists = fs.existsSync(dir);
  if (exists) {
    stats = fs.statSync(dir);
    if (!stats.isDirectory()) {
      return null;
    }
    return dir;
  }
  parent = path.dirname(dir);
  result = mkdirp(parent);
  if (result == null) {
    return null;
  }
  try {
    fs.mkdirSync(dir);
  } catch (_error) {
    e = _error;
    return null;
  }
  return dir;
};

getConfigurationDefault = function() {
  var result;
  result = {
    verbose: false,
    debug: false,
    serve: false,
    port: 3000,
    heap: true,
    profile: true,
    data: utils.replaceTilde("~/." + pkg.name + "/data"),
    config: utils.replaceTilde("~/." + pkg.name + "/config.json")
  };
  return result;
};

getConfigurationConfig = function(file) {
  var contents, e;
  try {
    contents = fs.readFileSync(file, "utf8");
    contents = JSON.parse(contents);
  } catch (_error) {
    e = _error;
    contents = {};
  }
  return contents;
};

getConfigurationEnv = function() {
  var port, result;
  result = {};
  port = process.env.PORT;
  if (port != null) {
    result.port = port;
  }
  return result;
};

getConfigurationCommandLine = function(opts) {
  return opts;
};

parseCommandLine = function(argv) {
  var args, optionSpecs, opts, parsed, shortHands;
  optionSpecs = {
    verbose: Boolean,
    debug: Boolean,
    serve: Boolean,
    heap: Boolean,
    profile: Boolean,
    port: Number,
    data: path,
    config: path,
    help: Boolean
  };
  shortHands = {
    v: "--verbose",
    d: "--debug",
    s: "--serve",
    h: "--heap",
    r: "--profile",
    p: "--port",
    d: "--data",
    c: "--config",
    "?": "--help"
  };
  if (argv[0] === "?") {
    exports.help();
  }
  parsed = nopt(optionSpecs, shortHands, argv, 0);
  if (parsed.help) {
    exports.help();
  }
  args = parsed.argv.remain;
  opts = parsed;
  delete opts.argv;
  return {
    args: args,
    opts: opts
  };
};

exports.help = function() {
  var text;
  text = "" + pkg.name + " " + pkg.version + "\n\n    will run an HTTP server to display profiling results,\n    or profile the execution of a node module\n\nusage:\n    " + pkg.name + " [options] [arguments]\n\noptions:\n    -c --config  path\n    -v --verbose \n    -x --debug \n    -p --port    Number\n    -d --data    path\n    -s --serve \n    -r --profile boolean\n\nUsing the --serve option will run the server, else the remainder\nof the command line will be used as the node module to profile.\n\nSee the `README.md` file for " + pkg.name + " for more information.";
  console.log(text);
  return process.exit();
};
